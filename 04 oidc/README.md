# Аутентификация пользователей с помощью OpenID Connect

Как Keycloak позволяет вам аутентифицировать пользователей в ваших приложениях, используя стандарт **OpenID Connect**. Через использование примера приложения, написанного специально для этой книги, мы увидим взаимодействие между приложением и Keycloak на практике, включая содержимое запросов и ответов.

Вы должны хорошо понимать **OpenID Connect**, включая то, как аутентифицировать пользователей, разобраться с ID-токеном и работать с выходом пользователей из системы.

Рассматриваются следующие основные темы:

- Запуск игровой площадки OpenID Connect
- Понимание конечной точки Discovery
- Аутентификация пользователя
- Понимание ID-токена
- Вызов конечной точки UserInfo
- Работа с выходом пользователей из системы

## Запуск игровой площадки OpenID Connect

Приложение-игровая площадка **OpenID Connect (OIDC)** было разработано специально для этой книги, чтобы максимально упростить понимание и экспериментирование с OIDC на практике.

Приложение не использует никаких библиотек для OIDC; все OIDC-запросы создаются самим приложением. Одно замечание: это приложение реализует OIDC небезопасным способом и игнорирует дополнительные параметры запросов, важные для рабочего приложения. Это сделано по двум причинам:
1. Чтобы вы могли сосредоточиться на понимании общих концепций OIDC.
2. Если вы решите создавать собственные библиотеки для OIDC, вам нужно хорошо понимать спецификации, и это выходит за рамки данной книги.

Прежде чем продолжить, вы должны запустить приложение-игровую площадку OIDC, так как оно будет использоваться далее

Чтобы запустить приложение-игровую площадку OIDC, откройте терминал и выполните следующие команды:

## Понимание конечной точки Discovery

Спецификация **OIDC Discovery** является важным аспектом как интероперабельности, так и удобства использования библиотек Relying Party для OIDC. Без этой спецификации вам бы требовалась ручная настройка в ваших приложениях для возможности аутентификации с помощью провайдера OpenID (подробнее об OpenID провайдерах можно узнать в 3).

Это необязательная спецификация, которую OpenID провайдер может решить реализовать или нет. К счастью, большинство провайдеров OpenID, включая Keycloak, реализуют эту спецификацию.

Зная только базовый URL (часто называемый issuer URL) вашего OpenID провайдера, Relying Party может открыть много полезной информации о провайдере. Это достигается загрузкой метаданных OpenID провайдера из стандартной конечной точки, а именно `<base URL>/.well-known/openid-configuration`.

Для лучшего понимания метаданных OpenID провайдера откройте OIDC игровую площадку в вашем браузере. Вы увидите, что уже есть значение, заполненное для поля issuer.

Уже заполненное значение для issuer URL — `http://localhost:8080/realms/myrealm`. Разберем этот URL и рассмотрим его части:

- `http://localhost:8080`: Это корневой URL для Keycloak. В рабочей системе это, конечно, будет реальное доменное имя и будет использовать HTTPS (например, `https://auth.mycompany.com/`).
- `/realms/myrealm`: Поскольку Keycloak поддерживает мультиарендность, это используется для разделения каждого реалма в вашем экземпляре Keycloak.

Если у вас Keycloak работает на другом хосте или порту, или у вас другой realm, вы должны изменить поле issuer. В противном случае, можете оставить его как есть.

Теперь нажмите "Load OpenID Provider Configuration". Когда вы нажмете на эту кнопку, приложение-игровая площадка отправляет запрос на `http://localhost:8080/realm/myrealm/.well-known/openid-configuration` (при условии, что вы не меняли issuer URL), и получает ответ в виде метаданных OpenID провайдера для данного экземпляра Keycloak. Полученные метаданные отображаются в секции **OpenID Provider Configuration** приложения-игровой площадки.

На следующем скриншоте из приложения-игровой площадки показан пример загруженных метаданных OpenID провайдера:

**Рисунок 4.2:** Метаданные OpenID провайдера для Keycloak

В следующем списке мы рассмотрим, что означают некоторые из этих значений:

- `authorization_endpoint`: URL для использования в запросах аутентификации.
- `token_endpoint`: URL для использования в запросах токенов.
- `introspection_endpoint`: URL для использования в запросах интроспекции.
- `userinfo_endpoint`: URL для использования в запросах UserInfo.
- `grant_types_supported`: Список поддерживаемых типов грантов.
- `response_types_supported`: Список поддерживаемых типов ответов.

Со всеми этими метаданными Relying Party может принимать разумные решения о том, как использовать OpenID провайдер, включая эндпоинты, куда отправлять запросы, и какие типы грантов и ответов можно использовать.

Если вы внимательно посмотрели на метаданные, вы могли заметить, что Keycloak поддерживает тип гранта `authorization_code` и типы ответов `code` и `token`. Это хорошие новости, поскольку мы будем использовать этот тип гранта и эти типы ответов для аутентификации пользователя в нашем приложении-игровой площадке в следующем разделе.

## Аутентификация пользователя

Наиболее распространенный способ аутентификации пользователя с помощью Keycloak — через поток кода авторизации **OpenID Connect**.

Вкратце, для аутентификации пользователя с этим потоком приложение перенаправляет на Keycloak, который отображает страницу входа для аутентификации пользователя. После аутентификации пользователь получает ID-токен, содержащий информацию о пользователе.

На следующей диаграмме показан поток кода авторизации более подробно:

**Рисунок 4.3:** Поток кода авторизации

Шаги из диаграммы объясняются более подробно ниже:

1. Пользователь нажимает кнопку входа в приложении.
2. Приложение создает запрос аутентификации.
3. Запрос аутентификации отправляется пользователю в виде 302-го перенаправления, указывая пользовательскому агенту перенаправить на эндпоинт авторизации, предоставленный Keycloak.
4. Пользовательский агент открывает эндпоинт авторизации с указанными приложением параметрами запроса.
5. Keycloak отображает страницу входа для пользователя. Пользователь вводит свое имя пользователя и учетные данные и отправляет форму.
6. После проверки учетных данных пользователя Keycloak создает код авторизации, который возвращается приложению.
7. Теперь приложение может обменять код авторизации на ID-токен, а также токен обновления.

Давайте попробуем вернуться к приложению-игровой площадке OIDC. Поскольку вы уже загрузили метаданные OpenID провайдера в предыдущем разделе, приложение-игровая площадка уже знает, куда отправлять запрос аутентификации. Чтобы отправить запрос аутентификации, нажмите кнопку "2 - Authentication".

Отобразится форма со следующими значениями, которые вы должны заполнить:

- `client_id`: Это идентификатор клиента для приложения, зарегистрированного в Keycloak. Если вы использовали значение, отличное от `oidc-playground`, при создании клиента, вы должны изменить это значение.
- `scope`: Значение по умолчанию — `openid`, что означает, что мы будем делать запрос OpenID. Оставьте это значение без изменений.
- `prompt`: Это может быть использовано для нескольких целей. Например, если вы введете значение `none` в этом поле, Keycloak не будет показывать экран входа пользователю, но аутентифицирует пользователя только в том случае, если пользователь уже вошел в систему с помощью Keycloak. Вы также можете использовать значение `login`, чтобы потребовать от пользователя повторный вход, даже если он уже вошел в систему с помощью Keycloak.
- `max_age`: Это максимальное количество секунд с момента последней аутентификации пользователя с помощью Keycloak. Например, если вы установите это поле в 60, это означает, что Keycloak повторно аутентифицирует пользователя, если прошло более 60 секунд с момента последней аутентификации.
- `login_hint`: Если приложение знает имя пользователя пользователя, которого оно хочет аутентифицировать, оно может использовать этот параметр, чтобы автоматически заполнить имя пользователя на странице входа.

Теперь давайте посмотрим, как будет выглядеть запрос аутентификации, нажав кнопку "Generate Authentication Request". Теперь вы увидите фактический запрос, на который приложение перенаправит пользовательский агент для инициирования аутентификации.

На следующем скриншоте из приложения-игровой площадки показан пример запроса аутентификации:

**Рисунок 4.4:** Запрос аутентификации

Это включает установку параметра `response_type` равным `code`, что означает, что приложение хочет получить код авторизации от Keycloak.

Далее нажмите кнопку "Send Authentication Request". Теперь вы будете перенаправлены на страницы входа Keycloak. Введите имя пользователя и пароль для вашего пользователя и нажмите "Log In".

Если вы хотите немного поэкспериментировать, вы можете, например, попробовать следующие шаги:

- Установите `prompt` в `login`: С этим значением Keycloak всегда будет требовать повторную аутентификацию.
- Установите `max_age` в 60: С этим значением Keycloak повторно аутентифицирует вас, если вы подождете хотя бы 60 секунд с момента последней аутентификации.
- Установите `login_hint` на ваше имя пользователя: Это должно автоматически заполнить имя пользователя на странице входа Keycloak.

Если вы попробуете любой из предыдущих шагов, не забудьте снова сгенерировать и отправить запрос аутентификации, чтобы увидеть, как себя ведет Keycloak.

После того, как Keycloak перенаправит обратно на приложение-игровую площадку, вы увидите ответ аутентификации в секции **Authentication Response**. Код — это так называемый код авторизации, который приложение использует для получения ID-токена и токена обновления.

Теперь, когда приложение имеет код авторизации, вы можете обменять его на некоторые токены.

Нажмите кнопку "3 - Token". Вы увидите, что код авторизации уже был заполнен в форме, поэтому вы можете нажать кнопку "Send Token Request".

Под **Token Request** вы можете увидеть запрос, который приложение отправляет на эндпоинт токена, предоставленный Keycloak. Он содержит код авторизации и устанавливает `grant_type` как `authorization_code`, что означает, что приложение хочет обменять код авторизации на токены.

Пример запроса токена показан на следующем скриншоте из приложения-игровой площадки:

**Рисунок 4.5:** Запрос токена

Под **Token Response** вы можете увидеть ответ, который Keycloak отправил приложению. Если вы получите ошибку со значением `invalid_grant`, скорее всего, это по одной из следующих двух причин:

- Вы выполнили шаги слишком медленно: Код авторизации действителен только одну минуту по умолчанию, поэтому если прошло больше минуты между получением ответа аутентификации от Keycloak и отправкой запроса токена, запрос завершится неудачей.
- Вы отправили запрос токена более одного раза: Код авторизации действителен только один раз, поэтому если он включен в несколько запросов токена, запрос завершится неудачей.

На следующем скриншоте показан пример успешного ответа токена из приложения-игровой площадки:

**Рисунок 4.6:** Ответ токена

Давайте рассмотрим значения внутри этого ответа:

- `access_token`: Это токен доступа, который в Keycloak является подписанным JWT. Мы рассмотрим это подробнее в следующий раздел, когда будем рассматривать OAuth 2.0 более детально.
- `expires_in`: Так как токен доступа иногда является непрозрачным, это даст приложению подсказку о времени истечения токена.
- `refresh_token`: Это токен обновления, который мы рассмотрим в следующем разделе.
- `refresh_token_expires_in`: Токен обновления также является непрозрачным, и это даст приложению подсказку о времени истечения токена обновления.
- `token_type`: Это тип токена доступа, который в Keycloak всегда является `bearer`.
- `id_token`: Это ID-токен, который мы рассмотрим более подробно в следующем разделе.
- `session_state`: Это идентификатор сессии пользователя с Keycloak.
- `scope`: Приложение запрашивает область видимости у Keycloak в запросе аутентификации, но фактическая возвращенная область видимости токенов может не совпадать с запрошенной областью.

В следующем разделе мы более подробно рассмотрим ID-токен, который приложение-игровая площадка только что получило от Keycloak.

## Понимание ID-токена

В предыдущем разделе вы получили ответ токена, включая ID-токен от Keycloak, но мы не очень внимательно рассмотрели содержимое ID-токена.

ID-токен по умолчанию является подписанным JSON Web Token (JWT), который следует этому формату:

```
<Header>.<Payload>.<Signature>
```

Заголовок и полезная нагрузка являются Base64 URL-закодированными JSON документами.

Если вы посмотрите на **Token Response** в приложении-игровой площадке, вы увидите ID-токен в его закодированном формате. Пример закодированного ID-токена также показан на следующем скриншоте из приложения-игровой площадки:

**Рисунок 4.7:** Закодированный ID-токен

Под секцией **ID Token** вы увидите декодированный токен, разделенный на три части. Заголовок сообщает вам, какой алгоритм используется, тип полезной нагрузки и идентификатор ключа ключа, который использовался для подписи токена.

Пример декодированного ID-токена показан на следующем скриншоте из приложения-игровой площадки:

**Рисунок 4.8:** Декодированный ID-токен

Давайте рассмотрим некоторые из утверждений (значений) внутри ID-токена:

- `exp`: Когда истекает токен.
- `iat`: Когда токен был выпущен.
- `auth_time`: Когда пользователь последний раз аутентифицировался.
- `jti`: Уникальный идентификатор для этого токена.
- `aud`: Аудитория токена, которая должна содержать Relying Party, аутентифицирующую пользователя.
- `azp`: Сторона, которой был выпущен токен.
- `sub`: Уникальный идентификатор для аутентифицированного пользователя. При ссылке на пользователя рекомендуется использовать это вместо имени пользователя или электронной почты, так как они могут меняться со временем.

Все времена в JWT представлены в формате Unix epoch time (секунды с 1 января 1970 года). Это не очень читаемо для человека, но отлично подходит для компьютеров и занимает очень мало места по сравнению с другими форматами. Вы можете найти удобный инструмент для преобразования времени эпохи в удобочитаемые даты по адресу [https://www.epochconverter.com/](https://www.epochconverter.com/).

Помимо перечисленных выше утверждений, есть информация о пользователе, такая как имя, фамилия и предпочитаемое имя пользователя.

Если вы посмотрите на значение `exp` для ID-токена на [https://www.epochconverter.com/](https://www.epochconverter.com/), вы заметите, что токен истекает всего через несколько минут.

Обычно ID-токены имеют короткую продолжительность, чтобы снизить риск утечки токенов. Это не означает, что приложение должно повторно аутентифицировать пользователя; скорее существует отдельный токен обновления, который можно использовать для получения обновленного ID-токена. Токен обновления имеет гораздо более длительное время действия и может использоваться только напрямую с Keycloak, что означает, что Keycloak может проверить, что токен все еще действителен.

Далее давайте попробуем обновить ID-токен. Нажмите кнопку "4 – Refresh", затем нажмите кнопку "Send Refresh Request".

В окне **Refresh Request** вы увидите запрос, отправленный приложением-игровой площадкой на эндпоинт токена Keycloak. Он использует тип гранта `refresh_token` и включает токен обновления и идентификатор клиента.

На следующем скриншоте из приложений-игровых площадок показан пример запроса обновления:

**Рисунок 4.9:** Запрос обновления

Под **Refresh Response** вы увидите ответ, который Keycloak отправил на игровую площадку. Он практически такой же, как и ответ для исходного запроса токена.

На следующем скриншоте из приложений-игровых площадок показан пример ответа на обновление:

**Рисунок 4.10:** Ответ на обновление

Одна вещь, которую следует отметить здесь, заключается в том, что ответ на обновление также включает токен обновления. Важно, чтобы приложение использовало этот обновленный токен обновления в следующий раз, когда оно захочет обновить ID-токен. Это важно по нескольким причинам, включая следующие:

- **Key rotation**: Keycloak может менять свои ключи подписи, и он полагается на то, что клиенты получают новые токены обновления, подписанные новыми ключами.
- **Session idle**: У клиента (или сессии) есть функция, называемая "время простоя сессии", что означает, что токен обновления может иметь более короткое время действия, чем связанная сессия.
- **Обнаружение утечки токенов обновления**: Для обнаружения утекших токенов обновления Keycloak не позволит повторного использования токенов обновления. Эта функция в настоящее время отключена по умолчанию в Keycloak.

Наконец, под **ID Token** вы можете заметить, что токен теперь имеет более или менее те же значения, за исключением времени истечения (exp), времени выпуска (iat) и нового идентификатора токена (jti), которые изменились.

Еще одно преимущество обновления токена сейчас заключается в том, что ваше приложение может обновить информацию о пользователе из Keycloak без необходимости повторной аутентификации. Теперь мы немного поэкспериментируем с этим.

Для следующих нескольких разделов вы должны оставить приложение-игровую площадку открытым. В новом окне браузера откройте Консоль администратора Keycloak, нажмите **Users** и найдите пользователя, которого вы использовали при аутентификации на приложении-игровой площадке.

## Обновление профиля пользователя

Измените электронную почту, имя и фамилию пользователя. Затем вернитесь к приложению-игровой площадке и нажмите кнопку "Send Refresh Request". Теперь вы заметите, что профиль пользователя был обновлен.

Теперь, когда вы попробовали обновить профиль пользователя, давайте попробуем добавить пользователю пользовательское свойство.

## Добавление пользовательского свойства

Давайте рассмотрим шаги для добавления пользовательского свойства:

1. Вернувшись в окно Консоли администратора Keycloak, которое должно все еще иметь открытого пользователя, нажмите **Attributes**.
2. В отображаемой таблице установите ключ как `myattribute` и значение как `myvalue`, затем нажмите **Save**. Теперь вы добавили пользовательский атрибут к пользователю, но он пока недоступен для приложения.
3. Теперь мы создадим так называемую область клиента. Область клиента позволяет создавать группы повторно используемых утверждений, которые добавляются к токенам, выдаваемым клиенту. В меню слева нажмите **Client Scopes**, затем нажмите **Create client scope**. В форме введите имя `myscope`. Оставьте все остальное без изменений и нажмите **Save**.
4. Теперь мы добавим пользовательский атрибут в область клиента, создав маппер. Нажмите **Mappers**, затем нажмите **Configure a new mapper**. Затем выберите **User Attribute**.

Заполните форму следующими значениями:

- **Name**: myattribute
- **User Attribute**: myattribute
- **Token Claim Name**: myattribute
- **Claim JSON Type**: String

5. Убедитесь, что опция **Add to ID Token** включена, затем нажмите **Save**. Далее мы добавим вашу новую созданную область клиента к клиенту.
6. В меню слева нажмите **Clients** и найдите приложение `oidc-playground`. Выберите **Client Scopes**; затем выберите окно **Add client scope**, выберите `myscope` и нажмите **Add**, и выберите **Optional**.

Поскольку мы добавили эту область в опциональные области для клиента, это означает, что клиент должен явно запрашивать эту область. Если бы вы добавили ее в области по умолчанию, она всегда добавлялась бы для клиента.

Мы делаем это, потому что хотим показать, как клиент может запрашивать разную информацию от Keycloak с помощью параметра области. Это позволяет клиенту запрашивать только ту информацию, которая ему нужна в данный момент, что особенно полезно при запросе дополнительного согласия пользователей на использование их данных, а также для избежания ненужных утверждений в токенах.

 

7. Теперь вернитесь к приложению-игровой площадке и снова нажмите кнопку "Send Refresh Request". Вы заметите, что ваше пользовательское свойство не было добавлено в ID-токен.

Если вы получили ошибку при обновлении токена, вероятно, ваша сессия единого входа (SSO) с Keycloak истекла. По умолчанию сессия SSO истекает, если нет активности в течение 10 минут. Позже в книге мы рассмотрим, как это изменить.

Теперь отправим новый запрос аутентификации, но на этот раз мы включим область `myscope`.

В приложении-игровой площадке нажмите "2 – Authentication". В поле scope установите значение `openid myscope`. Убедитесь, что оставили `openid`, иначе Keycloak не отправит вам ID-токен. Теперь снова выполните эти шаги, чтобы получить новый токен:

8. Нажмите "Generate Authentication Request".
9. Нажмите "Send Authentication Request".
10. Нажмите "3 – Token".
11. Нажмите "Send Token Request".

Теперь в полезной нагрузке ID-токена вы заметите пользовательское утверждение, которое вы только что добавили клиенту.

Теперь, когда вы добавили пользовательское свойство, давайте добавим роли в ID-токен.

## Добавление ролей в ID-токен

По умолчанию роли не добавляются в ID-токен. Вы можете изменить это поведение, перейдя в **Client Scopes**, затем выбрав область ролей. Нажмите **Mappers**, затем выберите **realm roles**. Включите **Add to ID Token**, затем нажмите **Save**.

Предполагая, что пользователь, которого вы используете, был создан  ранее — Начало работы с Keycloak, у пользователя должна быть связана роль реалма. Если это другой пользователь, убедитесь, что у него есть связанная роль реалма.

Вернитесь к приложению-игровой площадке и снова обновите токен. Теперь вы увидите `realm_access` внутри ID-токена.

По умолчанию все роли добавляются ко всем клиентам. Это не идеально, так как вы хотите ограничить доступ каждого отдельного клиента.

Это меньше влияет на ID-токен, так как он используется только для аутентификации пользователя для конкретного клиента, тогда как это оказывает большее влияние на токен доступа, который используется для доступа к другим службам.

К настоящему времени вы должны иметь довольно хорошее понимание того, как приложение использует ID-токен для аутентификации пользователя, а также для получения информации о пользователе. Если вы хотите поэкспериментировать с областями клиентов, сейчас хорошее время, так как приложение-игровая площадка позволит вам играть с областями и видеть результат в ID-токене.

В следующем разделе мы рассмотрим другой способ, которым приложение может получить информацию об аутентифицированном пользователе.

## Вызов конечной точки UserInfo

Помимо возможности находить информацию об аутентифицированном пользователе из ID-токена, также можно вызвать конечную точку UserInfo с токеном доступа, полученным через поток OIDC.

Давайте попробуем это, открыв приложение-игровую площадку. На этом этапе вам может потребоваться отправить новые запросы аутентификации и токенов, так как возможно, что ваша сессия SSO истекла.

Если вы быстрый читатель (или получили новые токены), то нажмите "5 – UserInfo". Под **UserInfo Request** вы увидите, что приложение-игровая площадка отправляет запрос на эндпоинт UserInfo Keycloak, включая токен доступа в заголовке авторизации.

На следующем скриншоте из приложения-игровой площадки показан пример запроса UserInfo:

**Рисунок 4.11:** Запрос UserInfo

Под **UserInfo Response** вы увидите ответ, который Keycloak отправил. Вы можете заметить, что здесь нет всех дополнительных полей из ID-токена, а просто простой JSON-ответ, включающий только атрибуты пользователя.

На следующем скриншоте из приложения-игровой площадки показан пример ответа UserInfo:

**Рисунок 4.12:** Ответ UserInfo

Точно так же, как вы можете настроить информацию, которую Keycloak возвращает в ID-токен через области клиентов и мапперы протокола, вы также можете настроить информацию, возвращаемую в конечной точке UserInfo. Кроме того, вы можете контролировать, какая информация возвращается клиенту, вызывающему конечную точку UserInfo, а не клиенту, получившему токен доступа. Это означает, что если один токен доступа отправляется двум различным серверам ресурсов, они могут видеть разную информацию в конечной точке UserInfo для одного и того же токена доступа.

Давайте попробуем добавить некоторую пользовательскую информацию в конечную точку UserInfo. На этот раз, вместо использования области клиента, мы добавим маппер протокола прямо к клиенту. Откройте Консоль администратора Keycloak, затем под **Clients** найдите клиент `oidc-playground`. Нажмите **Client scopes**, затем выберите клиентскую область `oidc-playground-dedicated`. Нажмите **Configure a new mapper**, и выберите **Hardcoded claim**. Наконец, заполните форму следующими значениями:

- **Name**: myotherclaim
- **Token Claim Name**: myotherclaim
- **Claim value**: My Other Claim
- **Claim JSON Type**: String

Убедитесь, что опция **Add to userinfo** включена, затем нажмите **Save**. Вернитесь к приложению-игровой площадке и отправьте новый запрос UserInfo, используя кнопку "Send UserInfo Request". Теперь вы увидите дополнительное утверждение `myotherclaim` в ответе.

Одна вещь, которую следует помнить о конечной точке UserInfo, заключается в том, что она может быть вызвана только с токеном доступа, полученным через поток OIDC. Мы можем попробовать это, перейдя к приложению-игровой площадке, затем нажав кнопку "2 – Authentication".

В поле `scope` удалите `openid`. Затем нажмите "Generate Authentication Request" и "Send Authentication Request".

Теперь нажмите "3 – Token", затем на "Send Token Request". Вы заметите, что в **Token Response** нет значения `id_token`, поэтому в секции **ID Token** не отображается ID-токен.

Теперь, если вы перейдете к "5 – UserInfo" и нажмете кнопку "Send UserInfo Request", вы также заметите, что запрос UserInfo завершается ошибкой.

В следующем разделе мы рассмотрим, как вы можете работать с выходом пользователей из системы.

## Работа с выходом пользователей из системы

Обработка выхода из системы в опыте единого входа может быть довольно сложной задачей, особенно если вы хотите мгновенный выход из всех приложений, которыми пользуется пользователь.

### Инициирование выхода

Выход, например, может быть инициирован пользователем, нажавшим кнопку выхода в приложении. Когда кнопка выхода нажата, приложение отправляет запрос на RP-инициированный выход OpenID Connect.

Приложение перенаправляет пользователя на эндпоинт **End Session** Keycloak, который зарегистрирован в метаданных OpenID провайдера как `end_session_endpoint`. Эндпоинт принимает следующие параметры:

- `id_token_hint`: Предварительно выданный ID-токен. Этот токен используется Keycloak для идентификации клиента, который выходит, пользователя, а также сессии, из которой клиент хочет выйти.
- `post_logout_redirect_uri`: Если клиент хочет, чтобы Keycloak перенаправил его обратно после выхода, он может передать URL в Keycloak. Клиент должен заранее зарегистрировать URL выхода в Keycloak.
- `state`: Это позволяет клиенту поддерживать состояние между запросом выхода и перенаправлением. Keycloak просто передает этот параметр при перенаправлении клиенту.
- `ui_locales`: Клиент может использовать этот параметр, чтобы подсказать Keycloak, какой язык следует использовать для экрана входа.

Когда Keycloak получает запрос на выход, он уведомляет других клиентов в той же сессии о выходе. Затем он аннулирует сессию, что фактически делает все токены недействительными.

### Использование истечения срока действия ID и токенов доступа

Самый простой и, возможно, самый надежный механизм для приложения, чтобы обнаружить, произошел ли выход, — это просто использовать тот факт, что срок действия ID и токенов доступа обычно короткий.

Поскольку Keycloak аннулирует сессию при выходе, токен обновления больше не может использоваться для получения новых токенов.

У этой стратегии есть недостаток: может пройти несколько минут с момента выхода пользователя до того, как все приложения будут фактически выведены из системы, но во многих случаях этого более чем достаточно.

Это также хорошая стратегия для публичных клиентов. Поскольку они обычно сами не предоставляют услуги, а используют токен доступа для вызова других сервисов, они быстро поймут, что сессия больше не действительна.

В случаях, когда токены имеют долгий срок действия, все равно хорошей практикой является периодическая проверка валидности токенов через эндпоинт **Token Introspection**, который мы рассмотрим в следующий раз.

## Управление сессиями и выходом пользователей в OIDC

### Управление сессиями через OIDC
Через **OIDC Session Management** приложение может обнаружить, была ли завершена сессия пользователя, без необходимости отправлять запросы к Keycloak или получать запросы от него.

Этот механизм работает за счет мониторинга состояния специального сеансового cookie, которым управляет Keycloak. Поскольку приложение обычно размещается на другом домене, чем Keycloak, оно не может напрямую прочитать этот cookie. Вместо этого используется скрытый HTML iframe, который загружает специальную страницу Keycloak для мониторинга значения cookie и отправляет событие в приложение, когда состояние сессии изменяется.

Это эффективная стратегия, особенно если приложение в данный момент открыто. Однако, если приложение закрыто, оно не сможет обнаружить выход до следующего открытия. Например, если рабочая станция была взломана, злоумышленник может предотвратить работу iframe, оставив сессию приложения открытой. Тем не менее, это можно относительно легко устранить:

- Один из вариантов — поддерживать сессию приложения только пока приложение открыто. Адаптер JavaScript Keycloak делает именно это, сохраняя токены только в состоянии окна.
- Кроме того, короткое время жизни токенов также помогает минимизировать риски.

К сожалению, подход **OIDC Session Management** становится менее актуальным, поскольку многие браузеры начали блокировать доступ к стороннему контенту. Это означает, что скрытый iframe больше не может получить доступ к сессионному cookie в некоторых браузерах. Поэтому не рекомендуется использовать этот подход в новых приложениях, и желательно отказаться от него в уже существующих.

### Выход через Back-Channel (обратный канал)

Через **OIDC Back-Channel Logout** приложение может зарегистрировать конечную точку для получения событий выхода.

Когда выход инициируется в Keycloak, он отправляет **logout token** всем приложениям в сессии, которые имеют зарегистрированную конечную точку выхода через обратный канал.

**Logout token** похож на ID токен и представляет собой подписанный JWT. При получении logout токена приложение проверяет его подпись и может завершить сессию, связанную с идентификатором сессии Keycloak.

Для серверных приложений использование выхода через обратный канал довольно эффективно. Однако это может стать сложным для кластеризованных приложений с "липкими" сессиями. Обычный подход к масштабированию состоятельных приложений заключается в распределении сессий между экземплярами приложения, и нет гарантии, что запрос на выход от Keycloak будет отправлен на тот же экземпляр приложения, который фактически хранит сессию. Настроить балансировщик нагрузки для маршрутизации запроса выхода к правильной сессии непросто, поэтому это обычно решается на уровне приложения.

Для безстатусных серверных приложений обработка запроса выхода также затруднена, так как сессия часто хранится в cookie. В этом случае приложение должно запомнить запрос на выход до тех пор, пока не будет сделан новый запрос для данной сессии, или пока сессия приложения не истечет.

### Примечание о выходе через Front-Channel (прямой канал)

Выход через **OpenID Connect Front-Channel Logout** создает скрытый iframe для каждого приложения, которое зарегистрировало конечную точку выхода через прямой канал на странице выхода провайдера OpenID. Теоретически это было бы удобным способом выхода из безстатусных серверных приложений, а также клиентских приложений. Однако на практике этот метод может быть ненадежным. Отсутствует эффективный способ для провайдера OpenID определить, успешно ли произошел выход из приложения, поэтому использование этого подхода может быть непредсказуемым.

Кроме того, подход **Front-Channel Logout** также страдает от блокировки браузерами стороннего контента, что означает, что когда провайдер OpenID открывает конечную точку выхода в iframe, доступ к любым cookies уровня приложения невозможен, оставляя приложение неспособным получить доступ к текущей сессии аутентификации.

### Как следует обрабатывать выход?

В итоге, простейший подход — просто полагаться на относительно короткие сессии приложений и срок действия токенов. Поскольку Keycloak сохраняет пользователя вошедшими в систему, возможно эффективно использовать короткие сессии приложений без необходимости частой повторной аутентификации пользователей.

В других случаях, или там, где выход должен происходить мгновенно, следует использовать **OIDC Back-Channel Logout**.